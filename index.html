<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PROZ Shader Lab</title>
    <style>
      :root { color-scheme: dark; }
      * { box-sizing: border-box; }
      html, body {
        margin: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background: #050608;
      }
      #shader-web-background { z-index: 0 !important; }
      .shader-web-background-fallback { background: #050608; }

      .panel {
        position: fixed;
        top: 16px;
        left: 16px;
        width: min(470px, calc(100vw - 32px));
        max-height: calc(100vh - 32px);
        overflow: auto;
        z-index: 2;
        background: rgba(12, 14, 20, 0.9);
        border: 1px solid rgba(255, 255, 255, 0.14);
        border-radius: 14px;
        padding: 14px;
        backdrop-filter: blur(10px);
      }
      .title { margin: 0 0 4px; font-size: 18px; color: #eef3ff; }
      .sub { margin: 0 0 12px; font-size: 12px; color: #aeb8cc; }
      .section-title {
        margin: 14px 0 8px;
        font-size: 11px;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: #96a4c2;
      }
      .grid { display: grid; grid-template-columns: 1fr; gap: 9px; }
      .row { display: grid; grid-template-columns: 1fr auto; gap: 8px; align-items: center; }
      label { font-size: 12px; color: #d6dded; }
      input[type='range'] { width: 100%; }
      .v { font-size: 11px; color: #8fa0c4; min-width: 56px; text-align: right; }

      .color-grid { display: grid; grid-template-columns: 1fr; gap: 8px; }
      .color-item {
        display: grid;
        grid-template-columns: auto 46px 1fr;
        gap: 8px;
        align-items: center;
      }
      input[type='color'] {
        width: 40px;
        height: 28px;
        border: none;
        background: transparent;
        padding: 0;
      }
      .hex {
        width: 100%;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.04);
        color: #eaf0ff;
        border-radius: 8px;
        padding: 6px 8px;
        font-size: 12px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      }
      .hex.invalid { border-color: rgba(255, 91, 122, 0.7); }

      .palette-row {
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 8px;
      }

      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 12px;
      }
      button, a.btn {
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(255, 255, 255, 0.05);
        color: #eaf0ff;
        border-radius: 999px;
        padding: 8px 12px;
        font-size: 12px;
        cursor: pointer;
        text-decoration: none;
      }
      button:hover, a.btn:hover { border-color: rgba(255, 255, 255, 0.45); }
      button:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }
      .status { margin-top: 8px; font-size: 11px; color: #9fb2da; min-height: 16px; }
    </style>
  </head>
  <body>
    <aside class="panel">
      <h1 class="title">Shader Lab</h1>
      <p class="sub">Tune live, paste hex palettes, then export baked GLSL or JSON preset.</p>

      <div class="section-title">Flow</div>
      <div class="grid">
        <div class="row"><label for="points">Points</label><span class="v" id="points-v"></span></div>
        <input id="points" type="range" min="1" max="14" step="1" value="6" />

        <div class="row"><label for="force">Force</label><span class="v" id="force-v"></span></div>
        <input id="force" type="range" min="0.2" max="6" step="0.01" value="2" />

        <div class="row"><label for="rotation">Rotation</label><span class="v" id="rotation-v"></span></div>
        <input id="rotation" type="range" min="0" max="12" step="0.01" value="4" />

        <div class="row"><label for="swirlFreq">Swirl Frequency</label><span class="v" id="swirlFreq-v"></span></div>
        <input id="swirlFreq" type="range" min="2" max="22" step="0.1" value="10" />

        <div class="row"><label for="speed">Speed</label><span class="v" id="speed-v"></span></div>
        <input id="speed" type="range" min="0.1" max="4" step="0.01" value="1" />

        <div class="row"><label for="zoom">Zoom</label><span class="v" id="zoom-v"></span></div>
        <input id="zoom" type="range" min="0.5" max="2" step="0.01" value="1" />

        <div class="row"><label for="drift">Drift</label><span class="v" id="drift-v"></span></div>
        <input id="drift" type="range" min="0" max="0.06" step="0.001" value="0" />
      </div>

      <div class="section-title">Light And Surface</div>
      <div class="grid">
        <div class="row"><label for="strength">Light Strength</label><span class="v" id="strength-v"></span></div>
        <input id="strength" type="range" min="0" max="1.6" step="0.01" value="0.5" />

        <div class="row"><label for="ambient">Ambient</label><span class="v" id="ambient-v"></span></div>
        <input id="ambient" type="range" min="0" max="1" step="0.01" value="0.5" />

        <div class="row"><label for="offset">Light Offset</label><span class="v" id="offset-v"></span></div>
        <input id="offset" type="range" min="0.2" max="3.5" step="0.01" value="1.3" />

        <div class="row"><label for="radius">Orbit Radius</label><span class="v" id="radius-v"></span></div>
        <input id="radius" type="range" min="0.2" max="2.2" step="0.01" value="1" />

        <div class="row"><label for="normalScale">Normal Scale</label><span class="v" id="normalScale-v"></span></div>
        <input id="normalScale" type="range" min="0.001" max="0.06" step="0.001" value="0.01" />

        <div class="row"><label for="specLow">Specular Low</label><span class="v" id="specLow-v"></span></div>
        <input id="specLow" type="range" min="0.4" max="0.99" step="0.005" value="0.85" />

        <div class="row"><label for="specHigh">Specular High</label><span class="v" id="specHigh-v"></span></div>
        <input id="specHigh" type="range" min="0.5" max="1.2" step="0.005" value="0.95" />
      </div>

      <div class="section-title">Color</div>
      <div class="grid">
        <div class="row"><label for="cycleSpeed">Color Cycle Speed</label><span class="v" id="cycleSpeed-v"></span></div>
        <input id="cycleSpeed" type="range" min="0" max="4" step="0.01" value="0" />

        <div class="row"><label for="cycleAmount">Color Cycle Amount</label><span class="v" id="cycleAmount-v"></span></div>
        <input id="cycleAmount" type="range" min="0" max="1" step="0.01" value="0" />

        <div class="row"><label for="gain">Gain</label><span class="v" id="gain-v"></span></div>
        <input id="gain" type="range" min="0.2" max="2.5" step="0.01" value="1" />

        <div class="row"><label for="gamma">Gamma</label><span class="v" id="gamma-v"></span></div>
        <input id="gamma" type="range" min="0.4" max="2.4" step="0.01" value="1" />

        <div class="row"><label for="accentMix">Accent Mix</label><span class="v" id="accentMix-v"></span></div>
        <input id="accentMix" type="range" min="0" max="1" step="0.01" value="0" />
      </div>

      <div class="section-title">Psychedelic FX</div>
      <div class="grid">
        <div class="row"><label for="hueShift">Hue Shift</label><span class="v" id="hueShift-v"></span></div>
        <input id="hueShift" type="range" min="-1" max="1" step="0.01" value="0" />

        <div class="row"><label for="huePulse">Hue Pulse</label><span class="v" id="huePulse-v"></span></div>
        <input id="huePulse" type="range" min="0" max="1" step="0.01" value="0" />

        <div class="row"><label for="saturation">Saturation</label><span class="v" id="saturation-v"></span></div>
        <input id="saturation" type="range" min="0" max="2.2" step="0.01" value="1" />

        <div class="row"><label for="contrast">Contrast</label><span class="v" id="contrast-v"></span></div>
        <input id="contrast" type="range" min="0.2" max="2.5" step="0.01" value="1" />

        <div class="row"><label for="brightness">Brightness</label><span class="v" id="brightness-v"></span></div>
        <input id="brightness" type="range" min="-0.4" max="0.4" step="0.01" value="0" />

        <div class="row"><label for="posterize">Posterize Steps</label><span class="v" id="posterize-v"></span></div>
        <input id="posterize" type="range" min="1" max="32" step="1" value="32" />

        <div class="row"><label for="posterizeMix">Posterize Mix</label><span class="v" id="posterizeMix-v"></span></div>
        <input id="posterizeMix" type="range" min="0" max="1" step="0.01" value="0" />

        <div class="row"><label for="grain">Grain</label><span class="v" id="grain-v"></span></div>
        <input id="grain" type="range" min="0" max="0.25" step="0.001" value="0" />

        <div class="row"><label for="vignette">Vignette</label><span class="v" id="vignette-v"></span></div>
        <input id="vignette" type="range" min="0" max="1" step="0.01" value="0" />
      </div>

      <div class="section-title">Palette</div>
      <div class="color-grid">
        <div class="color-item"><label for="c1">Color 1</label><input id="c1" type="color" value="#ff0000" /><input id="c1hex" class="hex" type="text" value="#ff0000" /></div>
        <div class="color-item"><label for="c2">Color 2</label><input id="c2" type="color" value="#00ff00" /><input id="c2hex" class="hex" type="text" value="#00ff00" /></div>
        <div class="color-item"><label for="c3">Color 3</label><input id="c3" type="color" value="#0000ff" /><input id="c3hex" class="hex" type="text" value="#0000ff" /></div>
        <div class="color-item"><label for="bg">Base Tint</label><input id="bg" type="color" value="#000000" /><input id="bghex" class="hex" type="text" value="#000000" /></div>
        <div class="color-item"><label for="accent">Accent</label><input id="accent" type="color" value="#ff49a8" /><input id="accenthex" class="hex" type="text" value="#ff49a8" /></div>
      </div>

      <div class="palette-row" style="margin-top:8px;">
        <input id="palette" class="hex" type="text" placeholder="#ff0000, #00ff00, #0000ff, #000000, #ff49a8" />
        <button id="apply-palette" type="button">Apply</button>
      </div>

      <div class="actions">
        <button id="copy-glsl" type="button">Copy GLSL</button>
        <button id="download-glsl" type="button">Download GLSL</button>
        <button id="copy-json" type="button">Copy JSON Preset</button>
        <button id="export-pack" type="button">Export Repro Pack</button>
        <button id="randomize" type="button">Randomize</button>
        <button id="undo" type="button" disabled>Undo</button>
        <button id="reset" type="button">Reset</button>
      </div>
      <div class="status" id="status"></div>
    </aside>

    <script src="assets/shader-web-background.min.js"></script>

    <script type="x-shader/x-fragment" id="Image">
      precision highp float;

      uniform vec2  iResolution;
      uniform float iTime;
      uniform float uPoints;
      uniform float uForce;
      uniform float uRotation;
      uniform float uSwirlFreq;
      uniform float uSpeed;
      uniform float uStrength;
      uniform float uAmbient;
      uniform float uOffset;
      uniform float uRadius;
      uniform float uNormalScale;
      uniform float uSpecLow;
      uniform float uSpecHigh;
      uniform float uZoom;
      uniform float uDrift;
      uniform float uCycleSpeed;
      uniform float uCycleAmount;
      uniform float uGain;
      uniform float uGamma;
      uniform float uAccentMix;
      uniform float uHueShift;
      uniform float uHuePulse;
      uniform float uSaturation;
      uniform float uContrast;
      uniform float uBrightness;
      uniform float uPosterize;
      uniform float uPosterizeMix;
      uniform float uGrain;
      uniform float uVignette;
      uniform vec3 uColor1;
      uniform vec3 uColor2;
      uniform vec3 uColor3;
      uniform vec3 uBase;
      uniform vec3 uAccent;

      float n21 (vec2 p)
      {
          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
      }

      mat2 rotate (float a)
      {
          float s = sin(a);
          float c = cos(a);
          return mat2(c, -s, s, c);
      }

      vec3 diffuseLight (vec2 uv, vec3 normals, vec3 pos, vec3 col)
      {
          vec3 dif = pos - vec3(uv, 0.);
          vec3 dir = normalize(dif);
          float intensity = 1. / length(dif);
          float diffuse   = dot(normals, dir) * intensity;
          return col * diffuse;
      }

      #define PI 3.14159265358979323846
      #define RATIO iResolution.x / iResolution.y
      #define MAX_POINTS 20

      vec2 swirl (vec2 uv, float seed, inout float acc_frc, inout vec2 acc_rot)
      {
          float tm = iTime * .05 * uSpeed;
          float n = n21(vec2(seed));
          vec2 pnt = vec2(.5) + vec2(cos(tm + n * 423.1), sin(tm + n * 254.3) * .5);

          vec2  dif = uv - pnt;
          float dis = length(dif);
          float wave = cos(dis * uSwirlFreq + iTime * .2 * uSpeed);
          float frc = smoothstep(.0, 1., exp(dis * -uForce) * (wave * .5 + .5));
          float swl = frc * sin(tm + n * 624.8) * uRotation;
          vec2  rot = dif * rotate(swl);

          acc_frc += frc;
          acc_rot += rot * frc;
          return rot + pnt;
      }

      vec3 cycleColor(vec3 a, vec3 b, float phase)
      {
          float t = .5 + .5 * sin(phase);
          return mix(a, b, t);
      }

      vec3 rgb2hsv(vec3 c)
      {
          vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
          vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
          vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

          float d = q.x - min(q.w, q.y);
          float e = 1.0e-10;
          return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
      }

      vec3 hsv2rgb(vec3 c)
      {
          vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);
          return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
      }

      vec3 applyFx(vec3 col, vec2 uv)
      {
          vec3 hsv = rgb2hsv(max(col, vec3(0.0)));
          hsv.x = fract(hsv.x + uHueShift + sin(iTime * (0.35 + uHuePulse * 4.0)) * (uHuePulse * 0.25));
          hsv.y = clamp(hsv.y * uSaturation, 0.0, 1.0);
          col = hsv2rgb(hsv);

          col = (col - 0.5) * uContrast + 0.5;
          col += uBrightness;

          float steps = max(1.0, uPosterize);
          vec3 poster = floor(max(col, vec3(0.0)) * steps) / steps;
          col = mix(col, poster, uPosterizeMix);

          float radial = length((uv - 0.5) * vec2(RATIO, 1.0));
          float v = 1.0 - smoothstep(0.15, 0.95, radial);
          col *= mix(1.0, v, uVignette);

          float grain = (n21(uv * iResolution.xy + iTime * 37.0) - 0.5) * uGrain;
          col += grain;

          return max(col, vec3(0.0));
      }

      vec3 offsetLights (vec2 uv, vec3 normals)
      {
          float tm  = iTime * .1 * uSpeed;
          vec3 pos  = vec3(.5, .5, 1.);

          float o2 = 1. * uOffset;
          float o3 = 2. * uOffset;

          vec3 p1 = vec3(pos.x + cos(tm) * uRadius, pos.y + sin(tm + 0.) * uRadius, pos.z);
          vec3 p2 = vec3(pos.x + cos(tm + o2) * uRadius, pos.y + sin(tm + o2) * uRadius, pos.z);
          vec3 p3 = vec3(pos.x + cos(tm + o3) * uRadius, pos.y + sin(tm + o3) * uRadius, pos.z);

          float cps = tm * 6.283 * max(0.001, uCycleSpeed);
          vec3 c1 = mix(uColor1, cycleColor(uColor1, uColor2, cps + 0.0), uCycleAmount);
          vec3 c2 = mix(uColor2, cycleColor(uColor2, uColor3, cps + 1.7), uCycleAmount);
          vec3 c3 = mix(uColor3, cycleColor(uColor3, uColor1, cps + 3.4), uCycleAmount);

          vec3 l1 = diffuseLight(uv, normals, p1, c1 * uStrength);
          vec3 l2 = diffuseLight(uv, normals, p2, c2 * uStrength);
          vec3 l3 = diffuseLight(uv, normals, p3, c3 * uStrength);

          return l1 + l2 + l3 + (uBase * uAmbient);
      }

      void mainImage( out vec4 fragColor, in vec2 fragCoord )
      {
          vec2 uv = (fragCoord / iResolution.xy - .5) * vec2(RATIO, 1.) / max(0.001, uZoom) + .5;
          uv += vec2(sin(iTime * .13), cos(iTime * .11)) * uDrift;

          float acc_frc = .0;
          vec2  acc_rot = vec2(0.);
          vec2  sv = uv;
          for (int i = 0; i < MAX_POINTS; i++) {
              if (float(i) >= uPoints) break;
              sv = swirl(sv, fract(float(i+1) * 123.45), acc_frc, acc_rot);
          }

          vec3 normal = normalize(vec3(acc_rot, max(1e-4, acc_frc * uNormalScale)));

          vec3 diffuse   = offsetLights(uv, normal);
          vec3 specular  = smoothstep(uSpecLow, uSpecHigh, diffuse);
          vec3 light     = diffuse + specular;

          vec3 col = light + sin(light * PI) - light;
          col *= uGain;

          float iAvg = clamp((col.r + col.g + col.b) / 3., 0., 1.);
          col = mix(col, uAccent, uAccentMix * smoothstep(.45, 1.2, iAvg));
          col = pow(max(col, vec3(0.0)), vec3(1.0 / max(0.001, uGamma)));
          col = applyFx(col, uv);

          fragColor = vec4(col,1.0);
      }

      void main() {
        mainImage(gl_FragColor, gl_FragCoord.xy);
      }
    </script>

    <script>
      const defaults = {
        points: 6,
        force: 2,
        rotation: 4,
        swirlFreq: 10,
        speed: 1,
        zoom: 1,
        drift: 0,
        strength: 0.5,
        ambient: 0.5,
        offset: 1.3,
        radius: 1,
        normalScale: 0.01,
        specLow: 0.85,
        specHigh: 0.95,
        cycleSpeed: 0,
        cycleAmount: 0,
        gain: 1,
        gamma: 1,
        accentMix: 0,
        hueShift: 0,
        huePulse: 0,
        saturation: 1,
        contrast: 1,
        brightness: 0,
        posterize: 32,
        posterizeMix: 0,
        grain: 0,
        vignette: 0,
        c1: '#ff0000',
        c2: '#00ff00',
        c3: '#0000ff',
        bg: '#000000',
        accent: '#ff49a8',
      };

      const state = { ...defaults };
      const EXPORT_VERSION = 'repro-pack-v1';
      const UNDO_LIMIT = 120;
      const undoStack = [];
      const undoSnapshots = new Map();
      const sliderIds = [
        'points','force','rotation','swirlFreq','speed','zoom','drift','strength','ambient','offset','radius',
        'normalScale','specLow','specHigh','cycleSpeed','cycleAmount','gain','gamma','accentMix',
        'hueShift','huePulse','saturation','contrast','brightness','posterize','posterizeMix','grain','vignette'
      ];
      const colorIds = ['c1', 'c2', 'c3', 'bg', 'accent'];
      const status = document.getElementById('status');
      const undoButton = document.getElementById('undo');

      function normalizeHex(input) {
        const trimmed = input.trim();
        const m6 = trimmed.match(/^#?([0-9a-fA-F]{6})$/);
        if (m6) return `#${m6[1].toLowerCase()}`;
        const m3 = trimmed.match(/^#?([0-9a-fA-F]{3})$/);
        if (!m3) return null;
        const [r, g, b] = m3[1].toLowerCase().split('');
        return `#${r}${r}${g}${g}${b}${b}`;
      }

      function hexToRgb01(hex) {
        const h = hex.replace('#', '');
        const v = parseInt(h, 16);
        return [((v >> 16) & 255) / 255, ((v >> 8) & 255) / 255, (v & 255) / 255];
      }

      function hslToHex(h, s, l) {
        const hh = ((h % 360) + 360) % 360;
        const ss = Math.max(0, Math.min(1, s));
        const ll = Math.max(0, Math.min(1, l));
        const c = (1 - Math.abs(2 * ll - 1)) * ss;
        const x = c * (1 - Math.abs((hh / 60) % 2 - 1));
        const m = ll - c / 2;
        let r = 0; let g = 0; let b = 0;
        if (hh < 60) [r, g, b] = [c, x, 0];
        else if (hh < 120) [r, g, b] = [x, c, 0];
        else if (hh < 180) [r, g, b] = [0, c, x];
        else if (hh < 240) [r, g, b] = [0, x, c];
        else if (hh < 300) [r, g, b] = [x, 0, c];
        else [r, g, b] = [c, 0, x];
        const toHex = (v) => {
          const n = Math.round((v + m) * 255);
          return Math.max(0, Math.min(255, n)).toString(16).padStart(2, '0');
        };
        return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
      }

      function rand(min, max) {
        return min + Math.random() * (max - min);
      }

      function quantizeToStep(value, min, max, step) {
        if (!Number.isFinite(step) || step <= 0) return Math.min(max, Math.max(min, value));
        const n = Math.round((value - min) / step);
        return Math.min(max, Math.max(min, min + n * step));
      }

      function cloneState() {
        return { ...state };
      }

      function statesEqual(a, b) {
        const keys = Object.keys(defaults);
        for (const key of keys) {
          if (a[key] !== b[key]) return false;
        }
        return true;
      }

      function updateUndoButton() {
        undoButton.disabled = undoStack.length === 0;
      }

      function pushUndoSnapshot(snapshot) {
        if (!snapshot) return;
        const current = cloneState();
        if (statesEqual(snapshot, current)) return;
        const last = undoStack[undoStack.length - 1];
        if (last && statesEqual(last, snapshot)) return;
        undoStack.push(snapshot);
        if (undoStack.length > UNDO_LIMIT) undoStack.shift();
        updateUndoButton();
      }

      function beginUndoCapture(key) {
        if (!undoSnapshots.has(key)) undoSnapshots.set(key, cloneState());
      }

      function commitUndoCapture(key) {
        const snapshot = undoSnapshots.get(key);
        if (snapshot) pushUndoSnapshot(snapshot);
        undoSnapshots.delete(key);
      }

      function randomizePalette() {
        const base = rand(0, 360);
        const shiftA = rand(65, 135);
        const shiftB = rand(190, 250);
        state.c1 = hslToHex(base, rand(0.75, 0.98), rand(0.42, 0.62));
        state.c2 = hslToHex(base + shiftA, rand(0.7, 0.96), rand(0.4, 0.64));
        state.c3 = hslToHex(base + shiftB, rand(0.7, 0.96), rand(0.42, 0.66));
        state.bg = hslToHex(base + rand(-22, 22), rand(0.2, 0.6), rand(0.03, 0.16));
        state.accent = hslToHex(base + rand(135, 300), rand(0.72, 1.0), rand(0.54, 0.74));
      }

      function randomizeState() {
        const preferredRanges = {
          points: [3, 14],
          force: [0.7, 5.0],
          rotation: [1.0, 10.0],
          swirlFreq: [4.0, 19.0],
          speed: [0.35, 2.8],
          zoom: [0.7, 1.45],
          drift: [0.0, 0.04],
          strength: [0.3, 1.25],
          ambient: [0.15, 0.85],
          offset: [0.75, 2.5],
          radius: [0.55, 1.7],
          normalScale: [0.004, 0.03],
          specLow: [0.7, 0.92],
          specHigh: [0.9, 1.15],
          cycleSpeed: [0.0, 2.6],
          cycleAmount: [0.0, 1.0],
          gain: [0.8, 1.9],
          gamma: [0.7, 1.5],
          accentMix: [0.0, 0.62],
          hueShift: [-0.3, 0.3],
          huePulse: [0.0, 0.95],
          saturation: [0.7, 2.1],
          contrast: [0.8, 2.1],
          brightness: [-0.16, 0.2],
          posterize: [4, 32],
          posterizeMix: [0.0, 0.72],
          grain: [0.0, 0.13],
          vignette: [0.0, 0.6],
        };

        sliderIds.forEach((id) => {
          const el = document.getElementById(id);
          const min = parseFloat(el.min);
          const max = parseFloat(el.max);
          const step = parseFloat(el.step);
          const range = preferredRanges[id] || [min, max];
          const lo = Math.max(min, range[0]);
          const hi = Math.min(max, range[1]);
          const value = quantizeToStep(rand(lo, hi), min, max, step);
          state[id] = value;
        });

        randomizePalette();
      }

      function setStatus(msg) {
        status.textContent = msg;
        setTimeout(() => {
          if (status.textContent === msg) status.textContent = '';
        }, 2200);
      }

      function downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);
      }

      function buildIntegrationConfig() {
        return {
          exportVersion: EXPORT_VERSION,
          generatedAt: new Date().toISOString(),
          runtime: {
            library: 'shader-web-background.min.js',
            global: 'shaderWebBackground',
            requiredUniforms: ['iResolution', 'iTime'],
          },
          placement: {
            target: 'body',
            zIndex: 0,
            pointerEvents: 'none',
          },
          layering: {
            contentZIndexHint: 1,
            note: 'Ensure site content is above shader canvas if needed.',
          },
          mobile: {
            recommendedMaxDevicePixelRatio: 1.5,
            note: 'Lower DPR reduces battery/thermal load.',
          },
        };
      }

      function buildEmbedSnippet(glsl, integration) {
        return `/* Auto-generated by PROZ Shader Lab (${EXPORT_VERSION}) */
const integration = ${JSON.stringify(integration, null, 2)};
const fragmentShader = ${JSON.stringify(glsl)};

if (!window.shaderWebBackground) {
  throw new Error('shaderWebBackground global not found. Load shader-web-background.min.js first.');
}

const existing = document.getElementById('Image');
if (existing) existing.remove();

const shaderScript = document.createElement('script');
shaderScript.id = 'Image';
shaderScript.type = 'x-shader/x-fragment';
shaderScript.textContent = fragmentShader;
document.body.appendChild(shaderScript);

window.shaderWebBackground.shade({
  shaders: {
    Image: {
      uniforms: {
        iResolution: (gl, loc, ctx) => gl.uniform2f(loc, ctx.width, ctx.height),
        iTime: (gl, loc) => gl.uniform1f(loc, performance.now() / 1000),
      },
    },
  },
});`;
      }

      function buildPackReadme(integration) {
        return `PROZ Shader Repro Pack
Generated: ${integration.generatedAt}
Version: ${integration.exportVersion}

Files:
- preset.json: UI slider + color values from Shader Lab
- shader.glsl: fully baked shader source
- integration.json: runtime/layering/mobile integration settings
- embed-snippet.js: drop-in init snippet (uses shader-web-background.min.js)

How to recreate:
1) Serve shader-web-background.min.js in your site assets.
2) Add shader.glsl as fragment shader script with id "Image" OR run embed-snippet.js.
3) Keep content layered above shader canvas (z-index hints in integration.json).
`;
      }

      function createCrc32Table() {
        const table = new Uint32Array(256);
        for (let i = 0; i < 256; i++) {
          let c = i;
          for (let j = 0; j < 8; j++) {
            c = (c & 1) ? (0xedb88320 ^ (c >>> 1)) : (c >>> 1);
          }
          table[i] = c >>> 0;
        }
        return table;
      }

      const CRC32_TABLE = createCrc32Table();

      function crc32(bytes) {
        let c = 0xffffffff;
        for (let i = 0; i < bytes.length; i++) {
          c = CRC32_TABLE[(c ^ bytes[i]) & 0xff] ^ (c >>> 8);
        }
        return (c ^ 0xffffffff) >>> 0;
      }

      function dosDateTime(date) {
        const year = Math.max(1980, date.getFullYear());
        const dosTime = ((date.getHours() & 31) << 11) | ((date.getMinutes() & 63) << 5) | ((Math.floor(date.getSeconds() / 2)) & 31);
        const dosDate = (((year - 1980) & 127) << 9) | (((date.getMonth() + 1) & 15) << 5) | (date.getDate() & 31);
        return { dosDate, dosTime };
      }

      function concatUint8(chunks) {
        const total = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const out = new Uint8Array(total);
        let offset = 0;
        for (const chunk of chunks) {
          out.set(chunk, offset);
          offset += chunk.length;
        }
        return out;
      }

      function buildZip(files) {
        const encoder = new TextEncoder();
        const now = new Date();
        const { dosDate, dosTime } = dosDateTime(now);
        const localChunks = [];
        const centralChunks = [];
        let localOffset = 0;

        for (const file of files) {
          const nameBytes = encoder.encode(file.name);
          const dataBytes = encoder.encode(file.content);
          const crc = crc32(dataBytes);

          const localHeader = new Uint8Array(30);
          const lv = new DataView(localHeader.buffer);
          lv.setUint32(0, 0x04034b50, true);
          lv.setUint16(4, 20, true);
          lv.setUint16(6, 0, true);
          lv.setUint16(8, 0, true);
          lv.setUint16(10, dosTime, true);
          lv.setUint16(12, dosDate, true);
          lv.setUint32(14, crc, true);
          lv.setUint32(18, dataBytes.length, true);
          lv.setUint32(22, dataBytes.length, true);
          lv.setUint16(26, nameBytes.length, true);
          lv.setUint16(28, 0, true);

          localChunks.push(localHeader, nameBytes, dataBytes);

          const centralHeader = new Uint8Array(46);
          const cv = new DataView(centralHeader.buffer);
          cv.setUint32(0, 0x02014b50, true);
          cv.setUint16(4, 20, true);
          cv.setUint16(6, 20, true);
          cv.setUint16(8, 0, true);
          cv.setUint16(10, 0, true);
          cv.setUint16(12, dosTime, true);
          cv.setUint16(14, dosDate, true);
          cv.setUint32(16, crc, true);
          cv.setUint32(20, dataBytes.length, true);
          cv.setUint32(24, dataBytes.length, true);
          cv.setUint16(28, nameBytes.length, true);
          cv.setUint16(30, 0, true);
          cv.setUint16(32, 0, true);
          cv.setUint16(34, 0, true);
          cv.setUint16(36, 0, true);
          cv.setUint32(38, 0, true);
          cv.setUint32(42, localOffset, true);

          centralChunks.push(centralHeader, nameBytes);
          localOffset += localHeader.length + nameBytes.length + dataBytes.length;
        }

        const centralData = concatUint8(centralChunks);
        const end = new Uint8Array(22);
        const ev = new DataView(end.buffer);
        ev.setUint32(0, 0x06054b50, true);
        ev.setUint16(4, 0, true);
        ev.setUint16(6, 0, true);
        ev.setUint16(8, files.length, true);
        ev.setUint16(10, files.length, true);
        ev.setUint32(12, centralData.length, true);
        ev.setUint32(16, localOffset, true);
        ev.setUint16(20, 0, true);

        const zipBytes = concatUint8([...localChunks, centralData, end]);
        return new Blob([zipBytes], { type: 'application/zip' });
      }

      function syncUI() {
        sliderIds.forEach((id) => {
          const el = document.getElementById(id);
          el.value = state[id];
          const out = document.getElementById(`${id}-v`);
          if (out) out.textContent = Number(state[id]).toFixed(3).replace(/\.000$/, '');
        });

        colorIds.forEach((id) => {
          document.getElementById(id).value = state[id];
          const hexEl = document.getElementById(`${id}hex`);
          hexEl.value = state[id];
          hexEl.classList.remove('invalid');
        });
      }

      sliderIds.forEach((id) => {
        const el = document.getElementById(id);
        el.addEventListener('focus', () => beginUndoCapture(`slider-${id}`));
        el.addEventListener('pointerdown', () => beginUndoCapture(`slider-${id}`));
        el.addEventListener('touchstart', () => beginUndoCapture(`slider-${id}`), { passive: true });
        el.addEventListener('input', () => {
          state[id] = parseFloat(el.value);
          const out = document.getElementById(`${id}-v`);
          if (out) out.textContent = Number(state[id]).toFixed(3).replace(/\.000$/, '');
        });
        el.addEventListener('change', () => commitUndoCapture(`slider-${id}`));
        el.addEventListener('blur', () => commitUndoCapture(`slider-${id}`));
      });

      colorIds.forEach((id) => {
        const picker = document.getElementById(id);
        const hexEl = document.getElementById(`${id}hex`);

        picker.addEventListener('focus', () => beginUndoCapture(`color-${id}`));
        picker.addEventListener('input', () => {
          state[id] = picker.value;
          hexEl.value = picker.value;
          hexEl.classList.remove('invalid');
        });
        picker.addEventListener('change', () => commitUndoCapture(`color-${id}`));
        picker.addEventListener('blur', () => commitUndoCapture(`color-${id}`));

        hexEl.addEventListener('focus', () => beginUndoCapture(`hex-${id}`));

        hexEl.addEventListener('input', () => {
          const hx = normalizeHex(hexEl.value);
          if (!hx) {
            hexEl.classList.add('invalid');
            return;
          }
          hexEl.classList.remove('invalid');
          state[id] = hx;
          picker.value = hx;
          hexEl.value = hx;
        });
        hexEl.addEventListener('blur', () => commitUndoCapture(`hex-${id}`));
      });

      document.getElementById('apply-palette').addEventListener('click', () => {
        const src = document.getElementById('palette').value;
        const found = src
          .split(/[\s,;|/]+/)
          .map((token) => normalizeHex(token))
          .filter(Boolean);
        if (found.length < 3) {
          setStatus('Paste at least 3 hex colors');
          return;
        }
        pushUndoSnapshot(cloneState());
        const mapped = [
          found[0] || state.c1,
          found[1] || state.c2,
          found[2] || state.c3,
          found[3] || state.bg,
          found[4] || state.accent,
        ];
        [state.c1, state.c2, state.c3, state.bg, state.accent] = mapped;
        syncUI();
        setStatus('Palette applied');
      });

      document.getElementById('reset').addEventListener('click', () => {
        pushUndoSnapshot(cloneState());
        Object.assign(state, defaults);
        syncUI();
        setStatus('Reset to defaults');
      });

      document.getElementById('randomize').addEventListener('click', () => {
        pushUndoSnapshot(cloneState());
        randomizeState();
        syncUI();
        setStatus('Randomized');
      });

      document.getElementById('undo').addEventListener('click', () => {
        if (!undoStack.length) {
          setStatus('Nothing to undo');
          return;
        }
        const previous = undoStack.pop();
        Object.assign(state, previous);
        syncUI();
        updateUndoButton();
        setStatus('Undid last change');
      });

      function buildExportShader() {
        const [r1, g1, b1] = hexToRgb01(state.c1);
        const [r2, g2, b2] = hexToRgb01(state.c2);
        const [r3, g3, b3] = hexToRgb01(state.c3);
        const [rb, gb, bb] = hexToRgb01(state.bg);
        const [ra, ga, ba] = hexToRgb01(state.accent);

        return `precision highp float;

uniform vec2  iResolution;
uniform float iTime;

float n21 (vec2 p)
{
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

mat2 rotate (float a)
{
    float s = sin(a);
    float c = cos(a);
    return mat2(c, -s, s, c);
}

vec3 diffuseLight (vec2 uv, vec3 normals, vec3 pos, vec3 col)
{
    vec3 dif = pos - vec3(uv, 0.);
    vec3 dir = normalize(dif);
    float intensity = 1. / length(dif);
    float diffuse   = dot(normals, dir) * intensity;
    return col * diffuse;
}

#define PI 3.14159265358979323846
#define RATIO iResolution.x / iResolution.y
#define POINTS ${Math.round(state.points)}
#define FORCE ${state.force.toFixed(4)}
#define ROTATION ${state.rotation.toFixed(4)}
#define SWIRL_FREQ ${state.swirlFreq.toFixed(4)}
#define SPEED ${state.speed.toFixed(4)}
#define ZOOM ${state.zoom.toFixed(4)}
#define DRIFT ${state.drift.toFixed(4)}
#define LIGHT_STRENGTH ${state.strength.toFixed(4)}
#define AMBIENT ${state.ambient.toFixed(4)}
#define OFFSET ${state.offset.toFixed(4)}
#define RADIUS ${state.radius.toFixed(4)}
#define NORMAL_SCALE ${state.normalScale.toFixed(4)}
#define SPEC_LOW ${state.specLow.toFixed(4)}
#define SPEC_HIGH ${state.specHigh.toFixed(4)}
#define CYCLE_SPEED ${state.cycleSpeed.toFixed(4)}
#define CYCLE_AMOUNT ${state.cycleAmount.toFixed(4)}
#define GAIN ${state.gain.toFixed(4)}
#define GAMMA ${state.gamma.toFixed(4)}
#define ACCENT_MIX ${state.accentMix.toFixed(4)}
#define HUE_SHIFT ${state.hueShift.toFixed(4)}
#define HUE_PULSE ${state.huePulse.toFixed(4)}
#define SATURATION ${state.saturation.toFixed(4)}
#define CONTRAST ${state.contrast.toFixed(4)}
#define BRIGHTNESS ${state.brightness.toFixed(4)}
#define POSTERIZE ${state.posterize.toFixed(4)}
#define POSTERIZE_MIX ${state.posterizeMix.toFixed(4)}
#define GRAIN ${state.grain.toFixed(4)}
#define VIGNETTE ${state.vignette.toFixed(4)}

const vec3 COLOR_1 = vec3(${r1.toFixed(6)}, ${g1.toFixed(6)}, ${b1.toFixed(6)});
const vec3 COLOR_2 = vec3(${r2.toFixed(6)}, ${g2.toFixed(6)}, ${b2.toFixed(6)});
const vec3 COLOR_3 = vec3(${r3.toFixed(6)}, ${g3.toFixed(6)}, ${b3.toFixed(6)});
const vec3 BASE_TINT = vec3(${rb.toFixed(6)}, ${gb.toFixed(6)}, ${bb.toFixed(6)});
const vec3 ACCENT = vec3(${ra.toFixed(6)}, ${ga.toFixed(6)}, ${ba.toFixed(6)});

vec2 swirl (vec2 uv, float seed, inout float acc_frc, inout vec2 acc_rot)
{
    float tm = iTime * .05 * SPEED;
    float n = n21(vec2(seed));
    vec2 pnt = vec2(.5) + vec2(cos(tm + n * 423.1), sin(tm + n * 254.3) * .5);

    vec2  dif = uv - pnt;
    float dis = length(dif);
    float wave = cos(dis * SWIRL_FREQ + iTime * .2 * SPEED);
    float frc = smoothstep(.0, 1., exp(dis * -FORCE) * (wave * .5 + .5));
    float swl = frc * sin(tm + n * 624.8) * ROTATION;
    vec2  rot = dif * rotate(swl);

    acc_frc += frc;
    acc_rot += rot * frc;
    return rot + pnt;
}

vec3 cycleColor(vec3 a, vec3 b, float phase)
{
    float t = .5 + .5 * sin(phase);
    return mix(a, b, t);
}

vec3 rgb2hsv(vec3 c)
{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}

vec3 hsv2rgb(vec3 c)
{
    vec3 p = abs(fract(c.xxx + vec3(0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0);
    return c.z * mix(vec3(1.0), clamp(p - 1.0, 0.0, 1.0), c.y);
}

vec3 applyFx(vec3 col, vec2 uv)
{
    vec3 hsv = rgb2hsv(max(col, vec3(0.0)));
    hsv.x = fract(hsv.x + HUE_SHIFT + sin(iTime * (0.35 + HUE_PULSE * 4.0)) * (HUE_PULSE * 0.25));
    hsv.y = clamp(hsv.y * SATURATION, 0.0, 1.0);
    col = hsv2rgb(hsv);

    col = (col - 0.5) * CONTRAST + 0.5;
    col += BRIGHTNESS;

    float steps = max(1.0, POSTERIZE);
    vec3 poster = floor(max(col, vec3(0.0)) * steps) / steps;
    col = mix(col, poster, POSTERIZE_MIX);

    float radial = length((uv - 0.5) * vec2(RATIO, 1.0));
    float v = 1.0 - smoothstep(0.15, 0.95, radial);
    col *= mix(1.0, v, VIGNETTE);

    float grain = (n21(uv * iResolution.xy + iTime * 37.0) - 0.5) * GRAIN;
    col += grain;

    return max(col, vec3(0.0));
}

vec3 offsetLights (vec2 uv, vec3 normals)
{
    float tm  = iTime * .1 * SPEED;
    vec3 pos  = vec3(.5, .5, 1.);

    float o2 = 1. * OFFSET;
    float o3 = 2. * OFFSET;

    vec3 p1 = vec3(pos.x + cos(tm) * RADIUS, pos.y + sin(tm + 0.) * RADIUS, pos.z);
    vec3 p2 = vec3(pos.x + cos(tm + o2) * RADIUS, pos.y + sin(tm + o2) * RADIUS, pos.z);
    vec3 p3 = vec3(pos.x + cos(tm + o3) * RADIUS, pos.y + sin(tm + o3) * RADIUS, pos.z);

    float cps = tm * 6.283 * max(0.001, CYCLE_SPEED);
    vec3 c1 = mix(COLOR_1, cycleColor(COLOR_1, COLOR_2, cps + 0.0), CYCLE_AMOUNT);
    vec3 c2 = mix(COLOR_2, cycleColor(COLOR_2, COLOR_3, cps + 1.7), CYCLE_AMOUNT);
    vec3 c3 = mix(COLOR_3, cycleColor(COLOR_3, COLOR_1, cps + 3.4), CYCLE_AMOUNT);

    vec3 l1 = diffuseLight(uv, normals, p1, c1 * LIGHT_STRENGTH);
    vec3 l2 = diffuseLight(uv, normals, p2, c2 * LIGHT_STRENGTH);
    vec3 l3 = diffuseLight(uv, normals, p3, c3 * LIGHT_STRENGTH);

    return l1 + l2 + l3 + (BASE_TINT * AMBIENT);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = (fragCoord / iResolution.xy - .5) * vec2(RATIO, 1.) / max(0.001, ZOOM) + .5;
    uv += vec2(sin(iTime * .13), cos(iTime * .11)) * DRIFT;

    float acc_frc = .0;
    vec2  acc_rot = vec2(0.);
    vec2  sv = uv;
    for (int i = 0; i < POINTS; i++)
        sv = swirl(sv, fract(float(i+1) * 123.45), acc_frc, acc_rot);

    vec3 normal = normalize(vec3(acc_rot, max(1e-4, acc_frc * NORMAL_SCALE)));

    vec3 diffuse   = offsetLights(uv, normal);
    vec3 specular  = smoothstep(SPEC_LOW, SPEC_HIGH, diffuse);
    vec3 light     = diffuse + specular;

    vec3 col = light + sin(light * PI) - light;
    col *= GAIN;

    float iAvg = clamp((col.r + col.g + col.b) / 3., 0., 1.);
    col = mix(col, ACCENT, ACCENT_MIX * smoothstep(.45, 1.2, iAvg));
    col = pow(max(col, vec3(0.0)), vec3(1.0 / max(0.001, GAMMA)));
    col = applyFx(col, uv);

    fragColor = vec4(col,1.0);
}

void main() {
  mainImage(gl_FragColor, gl_FragCoord.xy);
}`;
      }

      async function copyText(text, okMsg) {
        await navigator.clipboard.writeText(text);
        setStatus(okMsg);
      }

      document.getElementById('copy-glsl').addEventListener('click', async () => {
        try {
          await copyText(buildExportShader(), 'GLSL copied');
        } catch {
          setStatus('Clipboard blocked');
        }
      });

      document.getElementById('download-glsl').addEventListener('click', () => {
        const blob = new Blob([buildExportShader()], { type: 'text/plain;charset=utf-8' });
        downloadBlob(blob, 'custom-shader.glsl');
        setStatus('GLSL downloaded');
      });

      document.getElementById('copy-json').addEventListener('click', async () => {
        try {
          await copyText(JSON.stringify(state, null, 2), 'Preset JSON copied');
        } catch {
          setStatus('Clipboard blocked');
        }
      });

      document.getElementById('export-pack').addEventListener('click', () => {
        try {
          const glsl = buildExportShader();
          const integration = buildIntegrationConfig();
          const generatedAt = integration.generatedAt;
          const preset = {
            exportVersion: EXPORT_VERSION,
            generatedAt,
            state: { ...state },
          };

          const files = [
            { name: 'preset.json', content: JSON.stringify(preset, null, 2) },
            { name: 'shader.glsl', content: glsl },
            { name: 'integration.json', content: JSON.stringify(integration, null, 2) },
            { name: 'embed-snippet.js', content: buildEmbedSnippet(glsl, integration) },
            { name: 'README.txt', content: buildPackReadme(integration) },
          ];

          const zipBlob = buildZip(files);
          const stamp = generatedAt.replace(/[:.]/g, '-');
          downloadBlob(zipBlob, `shader-repro-pack-${stamp}.zip`);
          setStatus('Repro pack downloaded');
        } catch {
          setStatus('Repro pack export failed');
        }
      });

      syncUI();
      updateUndoButton();

      shaderWebBackground.shade({
        shaders: {
          Image: {
            uniforms: {
              iResolution: (gl, loc, ctx) => gl.uniform2f(loc, ctx.width, ctx.height),
              iTime: (gl, loc) => gl.uniform1f(loc, performance.now() / 1000),
              uPoints: (gl, loc) => gl.uniform1f(loc, state.points),
              uForce: (gl, loc) => gl.uniform1f(loc, state.force),
              uRotation: (gl, loc) => gl.uniform1f(loc, state.rotation),
              uSwirlFreq: (gl, loc) => gl.uniform1f(loc, state.swirlFreq),
              uSpeed: (gl, loc) => gl.uniform1f(loc, state.speed),
              uStrength: (gl, loc) => gl.uniform1f(loc, state.strength),
              uAmbient: (gl, loc) => gl.uniform1f(loc, state.ambient),
              uOffset: (gl, loc) => gl.uniform1f(loc, state.offset),
              uRadius: (gl, loc) => gl.uniform1f(loc, state.radius),
              uNormalScale: (gl, loc) => gl.uniform1f(loc, state.normalScale),
              uSpecLow: (gl, loc) => gl.uniform1f(loc, state.specLow),
              uSpecHigh: (gl, loc) => gl.uniform1f(loc, state.specHigh),
              uZoom: (gl, loc) => gl.uniform1f(loc, state.zoom),
              uDrift: (gl, loc) => gl.uniform1f(loc, state.drift),
              uCycleSpeed: (gl, loc) => gl.uniform1f(loc, state.cycleSpeed),
              uCycleAmount: (gl, loc) => gl.uniform1f(loc, state.cycleAmount),
              uGain: (gl, loc) => gl.uniform1f(loc, state.gain),
              uGamma: (gl, loc) => gl.uniform1f(loc, state.gamma),
              uAccentMix: (gl, loc) => gl.uniform1f(loc, state.accentMix),
              uHueShift: (gl, loc) => gl.uniform1f(loc, state.hueShift),
              uHuePulse: (gl, loc) => gl.uniform1f(loc, state.huePulse),
              uSaturation: (gl, loc) => gl.uniform1f(loc, state.saturation),
              uContrast: (gl, loc) => gl.uniform1f(loc, state.contrast),
              uBrightness: (gl, loc) => gl.uniform1f(loc, state.brightness),
              uPosterize: (gl, loc) => gl.uniform1f(loc, state.posterize),
              uPosterizeMix: (gl, loc) => gl.uniform1f(loc, state.posterizeMix),
              uGrain: (gl, loc) => gl.uniform1f(loc, state.grain),
              uVignette: (gl, loc) => gl.uniform1f(loc, state.vignette),
              uColor1: (gl, loc) => {
                const [r, g, b] = hexToRgb01(state.c1);
                gl.uniform3f(loc, r, g, b);
              },
              uColor2: (gl, loc) => {
                const [r, g, b] = hexToRgb01(state.c2);
                gl.uniform3f(loc, r, g, b);
              },
              uColor3: (gl, loc) => {
                const [r, g, b] = hexToRgb01(state.c3);
                gl.uniform3f(loc, r, g, b);
              },
              uBase: (gl, loc) => {
                const [r, g, b] = hexToRgb01(state.bg);
                gl.uniform3f(loc, r, g, b);
              },
              uAccent: (gl, loc) => {
                const [r, g, b] = hexToRgb01(state.accent);
                gl.uniform3f(loc, r, g, b);
              },
            },
          },
        },
      });
    </script>
  </body>
</html>
